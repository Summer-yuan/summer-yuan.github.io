<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>backtracking</title>
    <url>/2021/06/07/backtracking/</url>
    <content><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。</p>
<p>但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h1 id="与穷举的联系"><a href="#与穷举的联系" class="headerlink" title="与穷举的联系"></a>与穷举的联系</h1><p>回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。</p>
<p>一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。</p>
<p>回溯法的特点是深度优先遍历，也就是该问题的遍历顺序是1-&gt;2-&gt;3，然后从子节点3返回，从子节点2返回，再到1-&gt;3-&gt;2，以此类推。</p>
<p>状态的返回只有当前的节点不再满足问题的条件或者我们已经找到了问题的一个解时，才会返回，否则会以深度优先一直在解空间树内遍历下去。</p>
<p>当然，对于某些问题如果其解空间过大，即使用回溯法进行计算也有很高的时间复杂度，因为回溯法会尝试解空间树中所有的分支。</p>
<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>所以根据这类问题，我们有一些优化剪枝策略以及启发式搜索策略。</p>
<p>所谓优化剪枝策略，就是判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</p>
<p>所谓启发式搜索策略指的是，给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</p>
<h1 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h1><p>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。</p>
<p>用回溯算法解决问题的一般步骤：</p>
<p>1、针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</p>
<p>2、确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</p>
<p>3、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Value&gt; result;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径，选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">        result.add(路径);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择： 选择列表)&#123;</span><br><span class="line">        做选择；</span><br><span class="line">        backtrack(路径，选择列表);</span><br><span class="line">        撤销选择；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<p>回溯算法说白了就是穷举法。穷举的过程就是遍历一颗多叉树的过程。回溯算法的代码框架和多叉树遍历的代码框架类似。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</p>
<p>回溯法是一个既带有系统性又带有跳跃性的的搜索算法。</p>
<p>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。</p>
<p>算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。</p>
<p>如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。</p>
<p>否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。</p>
<p>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</p>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>回溯 data</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器配置</title>
    <url>/2021/06/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>软件版本：</p>
<p>Filezilla_3.52.2</p>
<p>VMware Workstation 15.5 PRO</p>
<p>SQLyog-13.1.7-0.x64Community</p>
<h1 id="Linux-安装Mysql-apt-get-版"><a href="#Linux-安装Mysql-apt-get-版" class="headerlink" title="Linux 安装Mysql    apt-get 版"></a>Linux 安装Mysql    apt-get 版</h1><h2 id="更新apt-get"><a href="#更新apt-get" class="headerlink" title="更新apt-get"></a>更新apt-get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<h3 id="安装时可能报错：Could-not-get-lock-var-lib-dpkg-lock-frontend"><a href="#安装时可能报错：Could-not-get-lock-var-lib-dpkg-lock-frontend" class="headerlink" title="安装时可能报错：Could not get lock /var/lib/dpkg/lock-frontend"></a>安装时可能报错：Could not get lock /var/lib/dpkg/lock-frontend</h3><h4 id="原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行"><a href="#原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行" class="headerlink" title="原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行"></a>原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行</h4><h4 id="解决方法：使用ps-和-grep-查找apt-的pid，并使用kill杀掉"><a href="#解决方法：使用ps-和-grep-查找apt-的pid，并使用kill杀掉" class="headerlink" title="解决方法：使用ps 和 grep 查找apt 的pid，并使用kill杀掉"></a>解决方法：使用ps 和 grep 查找apt 的pid，并使用kill杀掉</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">l:~$  ps afx|grep apt</span><br><span class="line">16214 ?        S      0:00  \_ sudo apt install rpm</span><br><span class="line">16215 ?        S      0:01  |   \_ apt install rpm</span><br><span class="line">16721 pts/3    S+     0:00          \_ grep --color=auto apt</span><br><span class="line">l:~$ <span class="built_in">kill</span> 16214</span><br><span class="line">bash: <span class="built_in">kill</span>: (16214) - Operation not permitted</span><br><span class="line">l:~$ sudo <span class="built_in">kill</span> 16214</span><br><span class="line">l:~$ sudo <span class="built_in">kill</span> 16215</span><br></pre></td></tr></table></figure>

<p>再执行安装命令即可！</p>
<h1 id="FTP互传文件"><a href="#FTP互传文件" class="headerlink" title="FTP互传文件"></a>FTP互传文件</h1><h2 id="Windows下安装FTP客户端"><a href="#Windows下安装FTP客户端" class="headerlink" title="Windows下安装FTP客户端"></a>Windows下安装FTP客户端</h2><p>在FileZilla官网下载安装即可</p>
<p>连接站点管理器中，端口默认不填，加密选择-只使用明文FTP，用户名密码为Ubuntu用户名密码，字符集选择-强制UTF-8</p>
<h2 id="Ubuntu下相关配置"><a href="#Ubuntu下相关配置" class="headerlink" title="Ubuntu下相关配置"></a>Ubuntu下相关配置</h2><h3 id="1、开启Ubuntu下的FTP服务"><a href="#1、开启Ubuntu下的FTP服务" class="headerlink" title="1、开启Ubuntu下的FTP服务"></a>1、开启Ubuntu下的FTP服务</h3><p>安装FTP服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>

<p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br></pre></td></tr></table></figure>

<p>保存退出，重启FTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure>

<h1 id="SQLyog连接mysql"><a href="#SQLyog连接mysql" class="headerlink" title="SQLyog连接mysql"></a>SQLyog连接mysql</h1><h2 id="ubuntu开放3306端口"><a href="#ubuntu开放3306端口" class="headerlink" title="ubuntu开放3306端口"></a>ubuntu开放3306端口</h2><h3 id="1、查看端口是否打开"><a href="#1、查看端口是否打开" class="headerlink" title="1、查看端口是否打开"></a>1、查看端口是否打开</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 3306</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.jpg" alt="端口"></p>
<h3 id="2、打开mysql配置文件"><a href="#2、打开mysql配置文件" class="headerlink" title="2、打开mysql配置文件"></a>2、打开mysql配置文件</h3><p>将bind-address = 127.0.0.1 注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<h3 id="3、重启ubuntu"><a href="#3、重启ubuntu" class="headerlink" title="3、重启ubuntu"></a>3、重启ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<h3 id="4、再次查看端口是否打开"><a href="#4、再次查看端口是否打开" class="headerlink" title="4、再次查看端口是否打开"></a>4、再次查看端口是否打开</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 3306</span><br></pre></td></tr></table></figure>

<p>此时3306端口已经打开</p>
<h2 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h2><p>登录： mysql -u root -p &lt;回车&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user =<span class="string">&#x27;root&#x27;</span> <span class="built_in">limit</span> 1;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br><span class="line">sudo service mysql start</span><br><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p>重启mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql restart </span><br></pre></td></tr></table></figure>

<p>到此，可以在任何主机连接此mysql数据库服务器了</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/17/hello-world/hello-world/</url>
    <content><![CDATA[<p>Welcome </p>
]]></content>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2021/06/07/test-1/test/</url>
    <content><![CDATA[<p>hello，world！</p>
<p>hello，Hexo！</p>
<p>[<img src="https://imgtu.com/i/2BQyW9" alt="2BQyW9.jpg">]</p>
<p><img src="/img/test.jpg" alt="外链图片"></p>
]]></content>
      <categories>
        <category>-test分类</category>
      </categories>
      <tags>
        <tag>-测试标签</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环中的++i和i++</title>
    <url>/2021/06/26/for%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>for(语句1;语句2;语句3)</p>
<p>语句1 在循环（代码块）开始前执行</p>
<p>语句2 定义运行循环（代码块）的条件</p>
<p>语句3 在循环（代码块）已被<em><strong>执行之后</strong></em>执行</p>
<p><strong>所以for循环条件中的++i 和 i++ 在结果上没有什么区别</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>但是，i++ 是在使用当前值后再加一，所以需要一个临时变量来转存</p>
<p>而++i 则是直接+1，省去了对内存的操作环节，相对而言能够提高性能！</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>小知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口-长度最小的子数组</title>
    <url>/2021/06/25/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>暴力解法两个for 遍历数组，不断寻找满足要求的子数组，并记录长度，显然时间复杂度为O(N^2)</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> length = nums.length;</span><br><span class="line">      <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">         sum = <span class="number">0</span>; <span class="comment">//清零，新的下标i处开始</span></span><br><span class="line">         <span class="comment">//不用担心一个i循环里面 前面数字小，sublength得到大值，而没有算后面的较小值</span></span><br><span class="line">         <span class="comment">//一个i里找到一个即可   总会遍历到较大nums[i] 开始计数的 较小的 sublength</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">            sum += nums[j];</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                  subLength = j -i + <span class="number">1</span>;</span><br><span class="line">                  result = subLength&lt;result ? subLength : result;</span><br><span class="line">                  </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p>
<p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p>滑动窗口的精妙之处在于<em><strong>根据当前子序列和大小的情况，不断调节子序列的起始位置</strong></em>。从而将O(n^2)的暴力解法降为O(n)。</p>
<p>核心代码：</p>
<p>begin 为起始位置，i 为结束位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( sum &gt;= target )&#123;</span><br><span class="line">            subLength = i - begin + <span class="number">1</span>;</span><br><span class="line">            result = subLength&lt;result ? subLength : result;</span><br><span class="line">            sum -= nums[begin++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> length = nums.length;</span><br><span class="line">      <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">         sum += nums[i];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            subLength = i - begin + <span class="number">1</span>;</span><br><span class="line">            result = subLength&lt;result ? subLength : result;</span><br><span class="line">            sum -= nums[begin++];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方</title>
    <url>/2021/06/20/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：<br>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2：<br>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h2><p>每个数平方后，重新排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是O(nlogn+n);</p>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>i指向起始位置，j指向终止位置</p>
<p>定义一个新数组result，让k指向result最终位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果nums[i] * nums[i] &lt; nums[j] * nums[j] 那么result[k--] = nums[j] * nums[j];</span><br><span class="line">如果nums[i] * nums[i] &gt; nums[j] * nums[j] 那么result[k--] = nums[i] * nums[i];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> num = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span> , j=num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123; <span class="comment">//i&lt;=j  最后两个比较完，i j 将会相等，这时还要再插入到新的数组中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                result[num--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[num--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，时间复杂度为O(n)</p>
<p><strong>双指针，妙啊！</strong></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/06/14/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>数组之二分法</p>
<p>一看就会，一些就废的二分查找</p>
<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二分法使用条件：</span><br><span class="line">    数组有序</span><br><span class="line">    数组无重复元素</span><br><span class="line"></span><br><span class="line">边界条件：</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br></pre></td></tr></table></figure>

<p>写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<h2 id="二分法第一种写法，-left-right"><a href="#二分法第一种写法，-left-right" class="headerlink" title="二分法第一种写法，[left,right]"></a>二分法第一种写法，[left,right]</h2><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 =</li>
<li>if ( nums [middle]  &gt;  target)   right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二分法第二种写法，-left-right"><a href="#二分法第二种写法，-left-right" class="headerlink" title="二分法第二种写法，[left,right)"></a>二分法第二种写法，[left,right)</h2><p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target)  right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]（已比较完毕）</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是要理解清楚边界的定义，在循环中要始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，在循环中坚持根据查找区间的定义来做边界处理。</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>35.<a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p>
<p>34.<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>69.<a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p>
<p>367.<a href="https://leetcode-cn.com/problems/valid-perfect-square/">https://leetcode-cn.com/problems/valid-perfect-square/</a></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_移除元素</title>
    <url>/2021/06/15/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p>
<p>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>两层for循环，一个for遍历数组，一个for更新数组</p>
<p>显然，暴力解法的时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len ; j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//越界警告</span></span><br><span class="line">                <span class="comment">// for(int j = i; j &lt; len ; j++)&#123;</span></span><br><span class="line">                <span class="comment">//     nums[j] = nums[j+1];</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//// 因为下表i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                <span class="comment">//i处理多个连续target数</span></span><br><span class="line">                <span class="comment">//[0,1,2,2,3,0,4,2]</span></span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; len; fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>26.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>283.<a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p>
<p>844.<a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a></p>
<p>977.<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2021/06/26/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/design-linked-list/">https://leetcode-cn.com/problems/design-linked-list/</a></p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素<strong>之前</strong>添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的<strong>第 index 个</strong>节点。</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>实现五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p><strong>链表操作的两种方式：</strong></p>
<ol>
<li>直接使用原来的链表来进行操作。</li>
<li>设置一个虚拟头结点在进行操作。</li>
</ol>
<p>下面采用的设置一个虚拟头结点（这样更方便一些，看代码就会感受出来）。</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">//链表大小</span></span><br><span class="line">    ListNode dummyHead; <span class="comment">//虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span> ;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="comment">//注意get for里面的index+1；</span></span><br><span class="line">        <span class="comment">//要获得下标index处的值，必须从dummyHead处走index+1 步 (0至index ) temp才能走到index位置 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp.next = dummyHead.next;</span><br><span class="line">        dummyHead.next = temp; <span class="comment">//保持虚拟头结点 的 相对位置</span></span><br><span class="line">        size ++ ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="comment">//java while循环中 判断条件 限制，以下while为错误的</span></span><br><span class="line">        <span class="comment">// while(index--)&#123;</span></span><br><span class="line">        <span class="comment">//     temp = temp.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//虚拟头结点 temp 指向插入处的前一个node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index ; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newNode.next = temp.next; </span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">		<span class="comment">//指向要删除的前一个结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index ; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>费马和帕斯卡系统</title>
    <url>/2021/06/27/%E6%9D%82%E4%B9%A6/%E8%B4%B9%E9%A9%AC%E5%92%8C%E5%B8%95%E6%96%AF%E5%85%8B/</url>
    <content><![CDATA[<p>《费马和帕斯卡系统的思维模型》；任何思维模型，在了解了其背后的原理后，都需要自己在实际生活中刻意去练习。费马帕斯卡系统给我们的启示是要用实际的概率去分析和做决策，不能以表面现象和自身经验去下结论。查理芒格说，我们只有把这些基础的不自然的数学概率方法变成我们生活的一部分，才不会把自己的优势拱手让给别人。</p>
<p>在知识、能力、努力、耐心这些所有的品质中，查理芒格最看重的是理性。查理芒格说：“你必须看到这个世界真实的样子，而不是你以为的样子、或者你希望的样子，只有这样你才能做出正确的选择。”费马帕斯卡系统就是认识真实世界的基本工具。<br><strong>费马帕斯卡系统是现代概率论的基础，来自一个概率论中的经典问题——点数问题（Problem of points），也叫赌注分配。</strong></p>
<p><img src="/img/%E8%B4%B9%E9%A9%AC%E5%92%8C%E5%B8%95%E6%96%AF%E5%8D%A1%E7%B3%BB%E7%BB%9F.jpg" alt="费马和帕斯卡"></p>
<p><strong>如果你们懂得基本的心理学原理，就能理解人们做不到这一点的原因。其实很简单：大脑的神经系统是经过长期的基因和文化进化而来的，它并不是费马—帕斯卡系统，它使用的是非常粗略而便捷的估算，里面有一点费马—帕斯卡系统的元素，但是不精准。—— 查理.芒格</strong></p>
]]></content>
      <categories>
        <category>杂书</category>
      </categories>
      <tags>
        <tag>思维模型</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/06/27/%E5%80%92%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<p>题意：反转一个单链表。</p>
<p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p>
<p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p>
<p><img src="/img/%E5%8F%8D%E8%BD%AC.jpg" alt="反转"></p>
<p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改表next指针的方向。</p>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p><img src="/img/%E5%8F%8D%E8%BD%AC.gif" alt="反转"></p>
<p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p>
<p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p>
<p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p>
<p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p>
<p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p>
<p>整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummpyNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = dummpyNode;</span><br><span class="line">            dummpyNode = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// dummpyNode = cur;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummpyNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以下小问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur;</span><br><span class="line">            cur.next = dummpyNode;</span><br><span class="line">            dummpyNode = temp;</span><br><span class="line">            cur = temp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个while是错误的，新建了临时节点temp，并将cur赋值给了temp，这并不是另批一个空间节点，把cur的值和下一跳给了temp。而是让temp也指向了链表中的cur节点，也就是说，temp和cur指向了同一块内存地址。所以下面一改cur.next，temp也就跟着变了，后面自然也就跟着错误了。</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表倒数第N个节点</title>
    <url>/2021/06/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p>
<p>示例 2：<br>输入：head = [1], n = 1<br>输出：[]</p>
<p>示例 3：<br>输入：head = [1,2], n = 1<br>输出：[1]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>思路是这样的，但要注意一些细节。</p>
<p>分为如下几步：</p>
<ul>
<li><p>首先推荐使用虚拟头结点，这样方便实现删除实际头结点的逻辑</p>
</li>
<li><p>定义fast指针和slow指针，初始值为虚拟头结点</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/1.jpg" alt="1"></p>
</li>
<li><p>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/2.jpg" alt="2"></p>
</li>
<li><p>fast和slow同时移动，之道fast指向末尾</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/3.jpg" alt="3"></p>
</li>
<li><p>删除slow指向的下一个节点</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/4.jpg" alt="4"></p>
</li>
</ul>
<h1 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummpyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        dummpyNode.next = head;</span><br><span class="line">        ListNode fast = dummpyNode ;</span><br><span class="line">        ListNode slow = dummpyNode;</span><br><span class="line">        <span class="comment">//fast先走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//一起往前走</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummpyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>上述fast先走n+1步，再和slow一起走，所以为啥是n+1，n可以吗？</p>
<p>答案是肯定的，先走n步完全是可以的，只不过这样走到最后slow就到了要删除的节点上，所以要在while里多做一步处理，记录下slow前面的节点，方便最后删除。</p>
<p>改动核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">     prev = slow; <span class="comment">//记录一哈</span></span><br><span class="line">     slow = slow.next;</span><br><span class="line">     fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里prev就起作用了</span></span><br><span class="line">prev.next = slow.next;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式必知必会</title>
    <url>/2021/09/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="4、使用元字符"><a href="#4、使用元字符" class="headerlink" title="4、使用元字符"></a>4、使用元字符</h1><p>元字符：正则表达式中有着特殊含义的字符(如’ .‘表示任意字符,[]表示字符区间)，这些字符要表达其本身意思的话，就要使用反斜杠字符\来转义</p>
<h2 id="4-1-匹配空白字符"><a href="#4-1-匹配空白字符" class="headerlink" title="4.1 匹配空白字符"></a>4.1 匹配空白字符</h2><p>\n 换行符</p>
<p>\r 回车符</p>
<p>\t 制表符</p>
<p>windows中文本行结束标志为 \r\n</p>
<p>\r  是指针回到本行的首字符处</p>
<p>\n 是跳到下一行原处</p>
<p><a href="https://blog.csdn.net/amqvje/article/details/38370681">\r\n解释</a></p>
<h3 id="4-2-匹配特定的字符类型"><a href="#4-2-匹配特定的字符类型" class="headerlink" title="4.2 匹配特定的字符类型"></a>4.2 匹配特定的字符类型</h3><h3 id="4-2-1-匹配数字"><a href="#4-2-1-匹配数字" class="headerlink" title="4.2.1 匹配数字"></a>4.2.1 匹配数字</h3><p>[0-9] 匹配任何一个数字  等价于 \d</p>
<p>[^0-9] 等价于\D</p>
<h3 id="4-2-2-匹配字母数字"><a href="#4-2-2-匹配字母数字" class="headerlink" title="4.2.2 匹配字母数字"></a>4.2.2 匹配字母数字</h3><p>[a-zA-Z0-9_]   任何一个字母数字字符或下划线  等价于 \w</p>
<p>[^a-zA-Z0-9_]  \W</p>
<p>4.2.3 匹配空白字符</p>
<p>[\f\n\r\t\v] 任何一个空白字符 等价于 \s</p>
<p>[^\f\n\r\t\v] 任何一个非空白字符 等价于 \S</p>
<h1 id="5、重复匹配"><a href="#5、重复匹配" class="headerlink" title="5、重复匹配"></a>5、重复匹配</h1><p>+是一个元字符</p>
<h2 id="5-1匹配一个或多个字符"><a href="#5-1匹配一个或多个字符" class="headerlink" title="5.1匹配一个或多个字符"></a>5.1匹配一个或多个字符</h2><p>[a-zA-Z0-9_]+   或 \w+</p>
<p>邮箱地址 ： \w+@\w+.\w+</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\w+@\w+\.\w+</span><br></pre></td></tr></table></figure>

<p>但不能识别全 <a href="mailto:&#98;&#x65;&#x6e;&#46;&#102;&#111;&#x72;&#x74;&#64;&#x66;&#x6f;&#x72;&#116;&#x2e;&#99;&#111;&#x6d;">&#98;&#x65;&#x6e;&#46;&#102;&#111;&#x72;&#x74;&#64;&#x66;&#x6f;&#x72;&#116;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>匹配字符集合: [\w.]  字符集中. + 这样的元字符不需要转义，被解释为普通字符。但转义了也没有坏处，效果是一样的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[\w.]+@[\w.]+\.\w+</span><br></pre></td></tr></table></figure>

<h2 id="5-1-2匹配零个或多个字符"><a href="#5-1-2匹配零个或多个字符" class="headerlink" title="5.1.2匹配零个或多个字符"></a>5.1.2匹配零个或多个字符</h2><p>+至少要匹配一个目标字符</p>
<p>*匹配一个可有可无的字符</p>
<p>[\w.]* 匹配.或字母数字字符的零次或多次重复</p>
<p><a href="mailto:&#x2e;&#98;&#x65;&#110;&#64;&#49;&#x35;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#x2e;&#98;&#x65;&#110;&#64;&#49;&#x35;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\w+[\w.]*@[\w.]+\.\w+</span><br></pre></td></tr></table></figure>

<p>过滤掉邮箱前面的.</p>
<h2 id="5-1-3匹配零个或一个字符"><a href="#5-1-3匹配零个或一个字符" class="headerlink" title="5.1.3匹配零个或一个字符"></a>5.1.3匹配零个或一个字符</h2><p>? 匹配可选文本，就算文本没有出现，也可匹配。但是与+不同， ？只能匹配某个字符（或字符集合）的零次或一次出现，最多不超过一次。</p>
<p>匹配URL地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https?:\/\/[\w.\/]+</span><br></pre></td></tr></table></figure>

<p>可匹配http://，也可匹配https:// 。</p>
<h2 id="5-2匹配的重复次数"><a href="#5-2匹配的重复次数" class="headerlink" title="5.2匹配的重复次数"></a>5.2匹配的重复次数</h2><p>{和}是元字符</p>
<h2 id="5-2-1-具体的重复匹配"><a href="#5-2-1-具体的重复匹配" class="headerlink" title="5.2.1 具体的重复匹配"></a>5.2.1 具体的重复匹配</h2><p>{3} 意味着匹配前一个字符（或字符集合）3次，如果只能匹配两次，则不算匹配成功。</p>
<h2 id="5-2-2区间范围"><a href="#5-2-2区间范围" class="headerlink" title="5.2.2区间范围"></a>5.2.2区间范围</h2><p>{2,4} 最少匹配2次，最多匹配4次</p>
<p>重复范围也可以从0开始，{0,3}表示重复次数可以是0,1,2,3.  ？等效于{0,1}</p>
<h2 id="5-2-3-匹配-至少重复多少次"><a href="#5-2-3-匹配-至少重复多少次" class="headerlink" title="5.2.3 匹配 至少重复多少次"></a>5.2.3 匹配 至少重复多少次</h2><p>{3,} 表示至少重复3次</p>
<p>+在功能上等效于{1,} </p>
<h1 id="6、位置匹配"><a href="#6、位置匹配" class="headerlink" title="6、位置匹配"></a>6、位置匹配</h1><h2 id="6-1-边界-boundary"><a href="#6-1-边界-boundary" class="headerlink" title="6.1 边界 boundary"></a>6.1 边界 boundary</h2><p>元字符 ： \b</p>
<h2 id="6-2-单词边界"><a href="#6-2-单词边界" class="headerlink" title="6.2 单词边界"></a>6.2 单词边界</h2><p>\b 匹配的是字符之间的一个位置 : 一边是单词(能够被\w匹配到的) ， 另一边是其他内容(被\W匹配到的字符)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the cat scattered his food</span><br><span class="line">正则：</span><br><span class="line">\bcat\b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射机制</title>
    <url>/2021/09/09/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.syl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我吃&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//利用反射机制调用类的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取类的字节码，字节码是根据源代码生成的，</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.syl.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、利用反射机制创建一个对象，以下的api 就是 调用类的无参构造器来实例化对象的</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、反射出 字节码中的某个方法</span></span><br><span class="line">        Method M = clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        Method m = clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、利用反射机制调用方法</span></span><br><span class="line">        <span class="comment">//把m 所代表的方法，当做obj对象的方法来调用</span></span><br><span class="line">        M.invoke(obj);</span><br><span class="line">        m.invoke(obj,<span class="string">&quot;大米饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>String类</title>
    <url>/2021/09/09/String%E7%B1%BB/</url>
    <content><![CDATA[<p>一、什么是String ?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符串不变; 它们的值在创建后不能被更改(字符串是长度不可以改变字符序列)。</span><br><span class="line">String是一个引用数据类型</span><br><span class="line">是jdk给我们提供好的一个现成的String类</span><br><span class="line"><span class="string">&quot;abc&quot;</span>既是一个字符串常量，也是一个字符串的对象(实例)</span><br></pre></td></tr></table></figure>

<p>二、常见的构造方法？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列</span><br><span class="line">2.public String(byte[] bytes)：将字节数组转换成字符串</span><br><span class="line">3.public String(byte[] bytes,int offset,int length)：将字节数组的一部分转换成字符串</span><br><span class="line">4.public String(char[] value)：将字符数组转换成字符串</span><br><span class="line">5.public String(char[] value,int offset,int count)：将字符数组的一部分转换成字符串</span><br><span class="line">6.public String(String original)：初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列</span><br><span class="line">7.String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">常见问题？</span><br><span class="line">问题1：</span><br><span class="line">通过new出来的String对象和直接赋值的String对象有什么区别？</span><br><span class="line">通过new出来的，在内存中有2个对象</span><br><span class="line">通过直接赋值的对象，在内存只有1个对象</span><br><span class="line"></span><br><span class="line">问题2：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s3 = new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);//<span class="literal">true</span></span><br><span class="line">System.out.println(s1 == s3);//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">问题3：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s3 = s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">问题4：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);//<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>三、常见成员方法？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.public char charAt(int index)：获取指定索引对应的字符</span><br><span class="line">2.public int compareTo(String anotherString)：按字典顺序比较两个字符串。</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;bccde&quot;</span> -&gt; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">对位比较，如果对位相等，去下一位再继续比</span><br><span class="line">3.public String concat(String str)：字符串的拼接</span><br><span class="line">4.public boolean contains(String s)：判断是否包含指定的字符串</span><br><span class="line">5.public String toLowerCase()：将大写字母转换成小写字母</span><br><span class="line">6.public String toUpperCase()：将小写字母转换成大写字母</span><br><span class="line">7.public boolean equals(Object anObject)：比较两个字符串的内容是否一致</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125; arr1[1]</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125; arr2[1]</span><br><span class="line">8.public boolean equalsIgnoreCase(String anotherString)：比较两个字符串的内容是否一致(不区分大小写)</span><br><span class="line">9.public int indexOf(int ch)：获取指定字符对应的索引值，如果找不到返回-1</span><br><span class="line">10.public int indexOf(String str)：获取指定字符串对应的索引值，如果找不到返回-1</span><br><span class="line">11.public int lastIndexOf(int ch)：获取指定字符对应的最后第一次出现的位置的索引，如果找不到返回-1</span><br><span class="line">12.public boolean isEmpty()：判断字符串是否为空串</span><br><span class="line">13.public int length()：获取字符串的长度</span><br><span class="line">14.public boolean startsWith(String prefix)：判断是否以指定的字符串为前缀的，开头</span><br><span class="line">15.public boolean endsWith(String suffix)：判断是否以指定的字符串为后缀的，结尾</span><br><span class="line">16.public String replace(char oldChar,char newChar)：替换字符</span><br><span class="line">17.public byte[] getBytes():将字符串转换成字节数组</span><br><span class="line">18.public char[] toCharArray()：将字符串转换成字符数组</span><br><span class="line">19.public String trim()：去除字符串的前后空格</span><br><span class="line">20.public String substring(int beginIndex):截取，从指定的索引开始截取到末尾</span><br><span class="line">21.public String substring(int beginIndex,int endIndex)：</span><br><span class="line">截取，从指定的beginIndex索引开始截取到endIndex(包头不包尾)</span><br><span class="line">22.public String[] split(String regex)：按照指定的符号进行切割，根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">正则表达式：是一个字符串，在字符串里面写一些规则，可以帮助对指定的String数据进行校验</span><br><span class="line">23.public String replace(String target,String replacement)：替换子字符串</span><br><span class="line"></span><br><span class="line">练习：</span><br><span class="line">需求：遍历字符串</span><br><span class="line">方式一：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String[] strs = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">	System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">	char ch = s.charAt(i);</span><br><span class="line">	System.out.println(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式三：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">char[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; chs.length; i++) &#123;</span><br><span class="line">	System.out.println(chs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">需求：已知字符串String s = <span class="string">&quot;adfasADFJASadfljdasjSFADASLJadfjaldj&quot;</span>;将首字母变大写，其余都变小写？</span><br><span class="line">System.out.println(s.substring(0,1).toUpperCase().concat(s.substring(1).toLowerCase()));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Math类</title>
    <url>/2021/09/10/Math%E7%B1%BB/</url>
    <content><![CDATA[<p>一、什么是Math？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 </span><br><span class="line">	数学工具类</span><br><span class="line"></span><br><span class="line">	注意：</span><br><span class="line">		工具类</span><br><span class="line">			构造是私有的</span><br><span class="line">			成员方法是静态的</span><br></pre></td></tr></table></figure>

<p>三、常见成员方法？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static int abs(int a)：获取绝对值</span><br><span class="line">public static int max(int a,int b)：获取最大值</span><br><span class="line">public static int min(int a,int b)：获取最小值</span><br><span class="line">public static double ceil(double a)：向上取整</span><br><span class="line">public static double floor(double a)：向下取整</span><br><span class="line">public static double pow(double a,double b)：a的b次方</span><br><span class="line">public static long round(double a)：四舍五入</span><br><span class="line">public static double random()：返回带正数的 double 值，该值大于等于 0.0 且小于 1.0</span><br><span class="line">[0.0, 1.0)</span><br><span class="line">    练习：	</span><br><span class="line">    需求：随机生成一个1-100之间的正整数？</span><br><span class="line">    (int)(Math.random() * 100) + 1</span><br><span class="line"></span><br><span class="line">    Math.random() -&gt; [0.0, 1.0)</span><br><span class="line">    Math.random()*100 -&gt; [0.0, 100.0)</span><br><span class="line">    (int)(Math.random() * 100) -&gt; [0, 99]</span><br><span class="line">    (int)(Math.random() * 100) + 1 -&gt; [1, 100]</span><br><span class="line"></span><br><span class="line">    需求：随机生成一个9-57之间的正整数？</span><br><span class="line">    57 - 9 = 48</span><br><span class="line">    (int)(Math.random() * 48) + 9 -&gt; [9, 57]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历Map</title>
    <url>/2021/09/13/%E9%81%8D%E5%8E%86Map/</url>
    <content><![CDATA[<p>Java遍历Map的四种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环遍历Map的4中方法</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 1. entrySet遍历，在键和值都需要时使用（最常用）</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;, value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 通过keySet或values来实现遍历,性能略低于第一种方式</span></span><br><span class="line">        <span class="comment">// 遍历map中的键</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历map中的值</span></span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 使用Iterator遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, Integer&gt; entry = it.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + entry.getKey() + <span class="string">&quot;, value = &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. java8 Lambda</span></span><br><span class="line">        <span class="comment">// java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，</span></span><br><span class="line">        <span class="comment">// 不过，经测试，性能低于entrySet,所以更推荐用entrySet的方式</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果只是获取key，或者value，推荐使用keySet或者values方式；</p>
<p>如果同时需要key和value推荐使用entrySet；</p>
<p>如果需要在遍历过程中删除元素推荐使用Iterator；</p>
<p>如果需要在遍历过程中增加元素，可以新建一个临时map存放新增的元素，等遍历完毕，再把临时map放到原来的map中。</p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>github上传、提交代码</title>
    <url>/2021/09/23/github%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="上传本地代码到github"><a href="#上传本地代码到github" class="headerlink" title="上传本地代码到github"></a>上传本地代码到github</h1><p>1、建立本地仓库</p>
<p>1.1 打开指定文件件，git gui 中 执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>把这个目录变成Git可以管理的仓库，项目文件多了一个隐藏文件夹.git</p>
<p>1.2 接着，将所有文件添加到仓库，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>1.2 然后，把文件提交到仓库，双引号内为提交注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交注释&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样，就建好本地仓库了。</p>
<p>2、关联github仓库</p>
<p>复制github仓库地址</p>
<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https:f*****.com/.git</span><br></pre></td></tr></table></figure>

<p>3、上传本地代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h1 id="github提交更改的代码"><a href="#github提交更改的代码" class="headerlink" title="github提交更改的代码"></a>github提交更改的代码</h1><p>更改本地的某一文件代码，对github上的同一个文件代码进行覆盖</p>
<p>1、先查看更改了哪些文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>2、添加更改的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add 更改的文件</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>3、提交本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交注释&quot;</span></span><br></pre></td></tr></table></figure>

<p>4、push</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/03/20/%E6%9C%80%E5%B0%91%E9%AA%8C%E6%AF%92/</url>
    <content><![CDATA[<p><strong>从一个经典问题开始</strong><br>有1000个瓶子里面装满了水，其中1瓶里面被加入了DY，但是滴入DY的水在外观上看和普通水是一模一样的，也就是说这1000个瓶子是分不清哪瓶是装有DY的，除非把装有DY的水喝进肚子里。现在有一只可怜的猪可以用来实验，将其中一瓶水喂给这只猪喝，如果猪毒发身亡了，说明这瓶水有毒。猪并不需要喝完整瓶水，只需喝到一小口，毒性就会发作，如果水是有毒的话。</p>
<p>由于只有一只猪，所以我们只能一瓶一瓶的去试验，假如毒发的时间是1分钟，那么我们每喂完一瓶水，就等待一分钟，直到猪死亡。值得注意的是，我们只需喂完999瓶水即可，因为如果猪喝完前面的999瓶水还没有中毒的话，说明最后一瓶一定是有毒的，已经不需要再试验了，同时这只猪也是幸运的，它可以告别死亡的命运。所以，我们最多需要花费999分钟，或者说试验999次才能找到这瓶装有DY的水。</p>
<p>那么问题来了，如果现在不是1只猪，而是有10只猪可以用来试验，那么你最少可以试验几次能找到这瓶有毒的水？</p>
<p><strong>答案</strong><br>如果你熟悉二进制的话，会知道答案是只需1次，没错，我们只需让每只猪喝1次水，总共花费1分钟即可找到这瓶有毒的水。<br>猪喝完一瓶水后，它只会有2种状态，要么活着要么死亡，如果把这个状态看作二进制的0和1的话，那么10只猪可以表示2^10^个状态，也就是1024个状态，已经超过1000个瓶子了，所以10只猪的前提下，我们只需试验1次即可。</p>
<p><strong>原理</strong><br>我们先将这1000瓶水，按0-999编号，前面说过10位二进制已经可以表示1024个状态了，所以完全能够表示这其中的所有编号。下面的表格是用二进制表示的所有编号：</p>
<p><img src="http://res.ylshi.top/202111251051863.png" alt="image-20211125105109703"></p>
<p>每只猪占据了一个二进制位，比如编号1的猪(Pig1)就相当于二进制的最低位，Pig10为二进制的最高位。<br>参照这个表格，我们按列给猪喂水，只喂其中标记为1的瓶子。比如Pig1，我们就将瓶子1、瓶子3…瓶子999的水倒出来合到一个桶里，准备喂给猪1，简称桶1。</p>
<p><img src="http://res.ylshi.top/202111251051704.png" alt="image-20211125105133664"></p>
<p>同理，我们将瓶子2、瓶子3…瓶子999的水再倒进另一个桶里准备喂给猪2，简称桶2。</p>
<p><img src="http://res.ylshi.top/202111251051068.png" alt="image-20211125105146032"></p>
<p>以此类推，我们最终得到了10个桶，然后让10只猪分别喝这10桶水，并记住他们的编号。1分钟后，毒性发作，此时观察这10只猪的状态，根据状态我们就能确定唯一的毒瓶子。<br>比如只有猪3死亡了，而其他猪都活着，那么一定是4号瓶子是有毒的水，因为除了猪3喝过4号瓶子，其他猪都没有。</p>
<p><img src="http://res.ylshi.top/202111251052019.png" alt="image-20211125105159984"></p>
<p>同理，如果只有猪4和猪5活着，其他猪都死了，那么一定是编号999的瓶子，因为死去的猪都要一个共通点，就是它们都喝过999号瓶子的水，而没死的猪一定没喝过999号瓶子。</p>
<p><img src="http://res.ylshi.top/202111251052901.png" alt="image-20211125105216863"></p>
<p>如果够幸运，所有的猪都没有死，那么有毒的水一定在0号瓶子里面，因为只有这瓶水，所有的猪都没有喝过。<br>所以，根据猪的死亡情况，对照着表格的行，1代表死亡，0代表活着，我们一定能确定一种状态，而这个状态就对应着毒瓶子的编号。</p>
<p><strong>进阶</strong><br>通过前面的原理分析我们已经知道，在试验1次的情况下，每只猪有2种状态，生或者死，反过来说，如果有2只猪，那么可以最多测试几个瓶子？答案是2^2^=4个瓶子，也就是状态数（2）的猪数量（2）次方。<br>假如我们给4个瓶子编号为0-3，2只猪分别表示A和B，用表格表示：</p>
<p><img src="http://res.ylshi.top/202111251053827.png" alt="image-20211125105304798"></p>
<p>根据表格所示，我们让A喝瓶子1和瓶子3，让B喝瓶子2和瓶子3，一轮结束过后，2只猪的死亡状态可以确定唯一的毒瓶子编号。<br>为了深刻印象，同理，3只猪可以测试2^3^=8个瓶子，我们用ABC代表3只猪，表格表示：</p>
<p><img src="http://res.ylshi.top/202111251053692.png" alt="image-20211125105339664"></p>
<p>根据表格所示，每只猪对应的喝水情况：</p>
<p>A：瓶子1，瓶子3，瓶子5，瓶子7<br>B：瓶子2，瓶子3，瓶子6，瓶子7<br>C：瓶子4，瓶子5，瓶子6，瓶子7<br>当你按此分配，得到任意一种猪的生死状态后，即使不对照表格，也能通过排除法得到毒瓶子，有兴趣的朋友可以自行验算。</p>
<p>前面都是试验1轮的情况，如果是试验2轮呢？那么每只猪就应该会有3种状态，<strong>活着，第1轮死掉、第2轮死掉</strong>。以1只猪为例，那么最多可以测试3^1^=3个瓶子，第1轮喝瓶子1，如果活着进入第2轮喝瓶子2，2轮过后一定能测3个瓶子，由于是3种状态，所以就不能用二进制了，而应该用三进制，表格表示：</p>
<p><img src="http://res.ylshi.top/202111251054923.png" alt="image-20211125105457896"></p>
<p>根据表格定义，假如猪最后的状态是状态2，也就是第二轮死掉，那么对应的毒瓶子编号就应该是2。</p>
<p>再来看2只猪试验2次的情况，同理，根据公式应该是3^2^=9，可以最多测9个瓶子，表格表示为：</p>
<p><img src="http://res.ylshi.top/202111251055997.png" alt="image-20211125105539968"></p>
<p>其中，A始终占据数值低位，B始终占据数值高位，试验1中只填充数值为1的位，试验2中只填充数值为2的位，所以喝水策略为:</p>
<p>第一轮：</p>
<p>A：瓶子1，瓶子4，瓶子7<br>B：瓶子3，瓶子4，瓶子5<br>第二轮：</p>
<p>A：瓶子2，瓶子5，瓶子8<br>B：瓶子6，瓶子7，瓶子8<br>以此策略喂猪喝水，我们一定能通过猪最后的状态确定唯一的毒瓶子。</p>
<p>总结：<br>猪的状态数为试验轮数+1，根据猪的状态数和猪的个数，可以确定最多能测试的瓶子数量，这是一个通用解。</p>
<p><strong>回到这个题目</strong><br>如果你已经看懂了上面的所有分析，那么这题就变成了一道数学题。<br>猪饮水中毒后会在 m 分钟内死亡，代表一次实验的时间为m分钟，需要在p分钟内找出，则代表可以实验p/m次，也就是是说每只猪可以有p/m+1个状态，而猪的数量是x，瓶子的数量是n，根据公式则有 (p/m+1)^x^=n，根据题目意思，p，m，n都是已知的，我们的目标就是求得满足该不等式 (p/m+1)^x^&gt;=n成立的x的最小整数值。<br>所以，对于这个通用函数，仅仅只需要一行代码：求以(p/m+1)为底，n的对数，并将结果向上取整。</p>
<pre><code>def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
    return math.ceil(math.log(buckets)/math.log(minutesToTest//minutesToDie+1))
</code></pre>
<p>利用对数的换底公式，可求任意底数的对数。</p>
<p>换一种思路：<br>猪的状态数代表着n进制，这个n是已知的，这个问题也可以看作是用n进制表示瓶子总数N需要的最小位数。比如对于十进制数字12，在十进制下表示需要2位，而二进制表示下是1100，则需要4位，现在我们只需将瓶子数转换成n进制表示，同时看会占据多少位即可。</p>
<pre><code>def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:
    if buckets==1:
        return 0
    def baseN(N, b):
        return &quot;0&quot; if N == 0 else (baseN(N // b, b).lstrip(&quot;0&quot;) + &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;[N % b])
    base=minutesToTest//minutesToDie+1
    return len(baseN(buckets-1,base))
</code></pre>
<p>原文地址：<a href="https://leetcode-cn.com/problems/poor-pigs/solution/ni-yi-ding-neng-kan-dong-de-ti-jie-xie-d-aanh/">https://leetcode-cn.com/problems/poor-pigs/solution/ni-yi-ding-neng-kan-dong-de-ti-jie-xie-d-aanh/</a></p>
<p>附：java Math类处理数据方法Math.round() ,Math.ceil() ,Math.floor().</p>
<p>Math.round()：四舍五入；Math.ceil()：向上取整；Math.floor()：向下取整</p>
]]></content>
  </entry>
</search>
