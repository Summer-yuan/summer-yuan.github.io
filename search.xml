<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>backtracking</title>
    <url>/2021/06/07/backtracking/</url>
    <content><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。</p>
<p>但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h1 id="与穷举的联系"><a href="#与穷举的联系" class="headerlink" title="与穷举的联系"></a>与穷举的联系</h1><p>回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。</p>
<p>一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。</p>
<p>回溯法的特点是深度优先遍历，也就是该问题的遍历顺序是1-&gt;2-&gt;3，然后从子节点3返回，从子节点2返回，再到1-&gt;3-&gt;2，以此类推。</p>
<p>状态的返回只有当前的节点不再满足问题的条件或者我们已经找到了问题的一个解时，才会返回，否则会以深度优先一直在解空间树内遍历下去。</p>
<p>当然，对于某些问题如果其解空间过大，即使用回溯法进行计算也有很高的时间复杂度，因为回溯法会尝试解空间树中所有的分支。</p>
<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><p>所以根据这类问题，我们有一些优化剪枝策略以及启发式搜索策略。</p>
<p>所谓优化剪枝策略，就是判断当前的分支树是否符合问题的条件，如果当前分支树不符合条件，那么就不再遍历这个分支里的所有路径。</p>
<p>所谓启发式搜索策略指的是，给回溯法搜索子节点的顺序设定一个优先级，从该子节点往下遍历更有可能找到问题的解。</p>
<h1 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h1><p>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。</p>
<p>用回溯算法解决问题的一般步骤：</p>
<p>1、针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</p>
<p>2、确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。</p>
<p>3、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Value&gt; result;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径，选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">        result.add(路径);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择： 选择列表)&#123;</span><br><span class="line">        做选择；</span><br><span class="line">        backtrack(路径，选择列表);</span><br><span class="line">        撤销选择；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<p>回溯算法说白了就是穷举法。穷举的过程就是遍历一颗多叉树的过程。回溯算法的代码框架和多叉树遍历的代码框架类似。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。</p>
<p>回溯法是一个既带有系统性又带有跳跃性的的搜索算法。</p>
<p>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。</p>
<p>算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。</p>
<p>如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。</p>
<p>否则，进入该子树，继续按深度优先的策略进行搜索。</p>
<p>回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。</p>
<p>而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。</p>
<p>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>回溯 data</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器配置</title>
    <url>/2021/06/16/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>软件版本：</p>
<p>Filezilla_3.52.2</p>
<p>VMware Workstation 15.5 PRO</p>
<p>SQLyog-13.1.7-0.x64Community</p>
<h1 id="Linux-安装Mysql-apt-get-版"><a href="#Linux-安装Mysql-apt-get-版" class="headerlink" title="Linux 安装Mysql    apt-get 版"></a>Linux 安装Mysql    apt-get 版</h1><h2 id="更新apt-get"><a href="#更新apt-get" class="headerlink" title="更新apt-get"></a>更新apt-get</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<h3 id="安装时可能报错：Could-not-get-lock-var-lib-dpkg-lock-frontend"><a href="#安装时可能报错：Could-not-get-lock-var-lib-dpkg-lock-frontend" class="headerlink" title="安装时可能报错：Could not get lock /var/lib/dpkg/lock-frontend"></a>安装时可能报错：Could not get lock /var/lib/dpkg/lock-frontend</h3><h4 id="原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行"><a href="#原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行" class="headerlink" title="原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行"></a>原因：这说明之前使用apt时出现异常，没有正常关闭，还在运行</h4><h4 id="解决方法：使用ps-和-grep-查找apt-的pid，并使用kill杀掉"><a href="#解决方法：使用ps-和-grep-查找apt-的pid，并使用kill杀掉" class="headerlink" title="解决方法：使用ps 和 grep 查找apt 的pid，并使用kill杀掉"></a>解决方法：使用ps 和 grep 查找apt 的pid，并使用kill杀掉</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">l:~$  ps afx|grep apt</span><br><span class="line">16214 ?        S      0:00  \_ sudo apt install rpm</span><br><span class="line">16215 ?        S      0:01  |   \_ apt install rpm</span><br><span class="line">16721 pts/3    S+     0:00          \_ grep --color=auto apt</span><br><span class="line">l:~$ <span class="built_in">kill</span> 16214</span><br><span class="line">bash: <span class="built_in">kill</span>: (16214) - Operation not permitted</span><br><span class="line">l:~$ sudo <span class="built_in">kill</span> 16214</span><br><span class="line">l:~$ sudo <span class="built_in">kill</span> 16215</span><br></pre></td></tr></table></figure>

<p>再执行安装命令即可！</p>
<h1 id="FTP互传文件"><a href="#FTP互传文件" class="headerlink" title="FTP互传文件"></a>FTP互传文件</h1><h2 id="Windows下安装FTP客户端"><a href="#Windows下安装FTP客户端" class="headerlink" title="Windows下安装FTP客户端"></a>Windows下安装FTP客户端</h2><p>在FileZilla官网下载安装即可</p>
<p>连接站点管理器中，端口默认不填，加密选择-只使用明文FTP，用户名密码为Ubuntu用户名密码，字符集选择-强制UTF-8</p>
<h2 id="Ubuntu下相关配置"><a href="#Ubuntu下相关配置" class="headerlink" title="Ubuntu下相关配置"></a>Ubuntu下相关配置</h2><h3 id="1、开启Ubuntu下的FTP服务"><a href="#1、开启Ubuntu下的FTP服务" class="headerlink" title="1、开启Ubuntu下的FTP服务"></a>1、开启Ubuntu下的FTP服务</h3><p>安装FTP服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure>

<p>打开配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/vsftpd.conf</span><br></pre></td></tr></table></figure>

<p>取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br></pre></td></tr></table></figure>

<p>保存退出，重启FTP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/vsftpd restart</span><br></pre></td></tr></table></figure>

<h1 id="SQLyog连接mysql"><a href="#SQLyog连接mysql" class="headerlink" title="SQLyog连接mysql"></a>SQLyog连接mysql</h1><h2 id="ubuntu开放3306端口"><a href="#ubuntu开放3306端口" class="headerlink" title="ubuntu开放3306端口"></a>ubuntu开放3306端口</h2><h3 id="1、查看端口是否打开"><a href="#1、查看端口是否打开" class="headerlink" title="1、查看端口是否打开"></a>1、查看端口是否打开</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 3306</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.jpg" alt="端口"></p>
<h3 id="2、打开mysql配置文件"><a href="#2、打开mysql配置文件" class="headerlink" title="2、打开mysql配置文件"></a>2、打开mysql配置文件</h3><p>将bind-address = 127.0.0.1 注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<h3 id="3、重启ubuntu"><a href="#3、重启ubuntu" class="headerlink" title="3、重启ubuntu"></a>3、重启ubuntu</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>

<h3 id="4、再次查看端口是否打开"><a href="#4、再次查看端口是否打开" class="headerlink" title="4、再次查看端口是否打开"></a>4、再次查看端口是否打开</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 3306</span><br></pre></td></tr></table></figure>

<p>此时3306端口已经打开</p>
<h2 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h2><p>登录： mysql -u root -p &lt;回车&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update mysql.user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user =<span class="string">&#x27;root&#x27;</span> <span class="built_in">limit</span> 1;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br><span class="line">sudo service mysql start</span><br><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p>重启mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysql restart </span><br></pre></td></tr></table></figure>

<p>到此，可以在任何主机连接此mysql数据库服务器了</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/17/hello-world/hello-world/</url>
    <content><![CDATA[<p>Welcome </p>
]]></content>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/2021/06/07/test-1/test/</url>
    <content><![CDATA[<p>hello，world！</p>
<p>hello，Hexo！</p>
<p>[<img src="https://imgtu.com/i/2BQyW9" alt="2BQyW9.jpg">]</p>
<p><img src="/img/test.jpg" alt="外链图片"></p>
]]></content>
      <categories>
        <category>-test分类</category>
      </categories>
      <tags>
        <tag>-测试标签</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环中的++i和i++</title>
    <url>/2021/06/26/for%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>for(语句1;语句2;语句3)</p>
<p>语句1 在循环（代码块）开始前执行</p>
<p>语句2 定义运行循环（代码块）的条件</p>
<p>语句3 在循环（代码块）已被<em><strong>执行之后</strong></em>执行</p>
<p><strong>所以for循环条件中的++i 和 i++ 在结果上没有什么区别</strong></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;++i)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>



<p>但是，i++ 是在使用当前值后再加一，所以需要一个临时变量来转存</p>
<p>而++i 则是直接+1，省去了对内存的操作环节，相对而言能够提高性能！</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>小知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口-长度最小的子数组</title>
    <url>/2021/06/25/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">https://leetcode-cn.com/problems/minimum-size-subarray-sum/</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<h1 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h1><p>暴力解法两个for 遍历数组，不断寻找满足要求的子数组，并记录长度，显然时间复杂度为O(N^2)</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> length = nums.length;</span><br><span class="line">      <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">         sum = <span class="number">0</span>; <span class="comment">//清零，新的下标i处开始</span></span><br><span class="line">         <span class="comment">//不用担心一个i循环里面 前面数字小，sublength得到大值，而没有算后面的较小值</span></span><br><span class="line">         <span class="comment">//一个i里找到一个即可   总会遍历到较大nums[i] 开始计数的 较小的 sublength</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++) &#123;</span><br><span class="line"></span><br><span class="line">            sum += nums[j];</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                  subLength = j -i + <span class="number">1</span>;</span><br><span class="line">                  result = subLength&lt;result ? subLength : result;</span><br><span class="line">                  </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。</p>
<p>滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。</p>
<p>在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p>
<p>滑动窗口的精妙之处在于<em><strong>根据当前子序列和大小的情况，不断调节子序列的起始位置</strong></em>。从而将O(n^2)的暴力解法降为O(n)。</p>
<p>核心代码：</p>
<p>begin 为起始位置，i 为结束位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( sum &gt;= target )&#123;</span><br><span class="line">            subLength = i - begin + <span class="number">1</span>;</span><br><span class="line">            result = subLength&lt;result ? subLength : result;</span><br><span class="line">            sum -= nums[begin++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> length = nums.length;</span><br><span class="line">      <span class="keyword">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">         sum += nums[i];</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            subLength = i - begin + <span class="number">1</span>;</span><br><span class="line">            result = subLength&lt;result ? subLength : result;</span><br><span class="line">            sum -= nums[begin++];</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>有序数组的平方</title>
    <url>/2021/06/20/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h1 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：<br>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2：<br>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><h2 id="暴力排序"><a href="#暴力排序" class="headerlink" title="暴力排序"></a>暴力排序</h2><p>每个数平方后，重新排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是O(nlogn+n);</p>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>i指向起始位置，j指向终止位置</p>
<p>定义一个新数组result，让k指向result最终位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">如果nums[i] * nums[i] &lt; nums[j] * nums[j] 那么result[k--] = nums[j] * nums[j];</span><br><span class="line">如果nums[i] * nums[i] &gt; nums[j] * nums[j] 那么result[k--] = nums[i] * nums[i];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> num = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span> , j=num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123; <span class="comment">//i&lt;=j  最后两个比较完，i j 将会相等，这时还要再插入到新的数组中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                result[num--] = nums[j] * nums[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[num--] = nums[i] * nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，时间复杂度为O(n)</p>
<p><strong>双指针，妙啊！</strong></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/06/14/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p>数组之二分法</p>
<p>一看就会，一些就废的二分查找</p>
<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>这道题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二分法使用条件：</span><br><span class="line">    数组有序</span><br><span class="line">    数组无重复元素</span><br><span class="line"></span><br><span class="line">边界条件：</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br></pre></td></tr></table></figure>

<p>写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<h2 id="二分法第一种写法，-left-right"><a href="#二分法第一种写法，-left-right" class="headerlink" title="二分法第一种写法，[left,right]"></a>二分法第一种写法，[left,right]</h2><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p>
<ul>
<li>while (left &lt;= right) 要使用 &lt;= ，因为left == right是有意义的，所以使用 =</li>
<li>if ( nums [middle]  &gt;  target)   right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二分法第二种写法，-left-right"><a href="#二分法第二种写法，-left-right" class="headerlink" title="二分法第二种写法，[left,right)"></a>二分法第二种写法，[left,right)</h2><p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target)  right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]（已比较完毕）</li>
</ul>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)  </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="keyword">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是要理解清楚边界的定义，在循环中要始终坚持根据查找区间的定义来做边界处理。</p>
<p>区间的定义就是不变量，在循环中坚持根据查找区间的定义来做边界处理。</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>35.<a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p>
<p>34.<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>69.<a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p>
<p>367.<a href="https://leetcode-cn.com/problems/valid-perfect-square/">https://leetcode-cn.com/problems/valid-perfect-square/</a></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组_移除元素</title>
    <url>/2021/06/15/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84_%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h1><p>题目地址：<a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p>
<p>示例 1:<br>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2:<br>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>
<p><strong>你不需要考虑数组中超出新长度后面的元素。</strong></p>
<h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>两层for循环，一个for遍历数组，一个for更新数组</p>
<p>显然，暴力解法的时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len ; j++)&#123;</span><br><span class="line">                    nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//越界警告</span></span><br><span class="line">                <span class="comment">// for(int j = i; j &lt; len ; j++)&#123;</span></span><br><span class="line">                <span class="comment">//     nums[j] = nums[j+1];</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">//// 因为下表i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line">                <span class="comment">//i处理多个连续target数</span></span><br><span class="line">                <span class="comment">//[0,1,2,2,3,0,4,2]</span></span><br><span class="line">                i--;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; len; fastIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val)&#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>26.<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>283.<a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p>
<p>844.<a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a></p>
<p>977.<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>设计链表</title>
    <url>/2021/06/26/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/design-linked-list/">https://leetcode-cn.com/problems/design-linked-list/</a></p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素<strong>之前</strong>添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的<strong>第 index 个</strong>节点。</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>实现五个接口：</p>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
<p><strong>链表操作的两种方式：</strong></p>
<ol>
<li>直接使用原来的链表来进行操作。</li>
<li>设置一个虚拟头结点在进行操作。</li>
</ol>
<p>下面采用的设置一个虚拟头结点（这样更方便一些，看代码就会感受出来）。</p>
<p>java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> val, ListNode next)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">//链表大小</span></span><br><span class="line">    ListNode dummyHead; <span class="comment">//虚拟头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        size = <span class="number">0</span> ;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="comment">//注意get for里面的index+1；</span></span><br><span class="line">        <span class="comment">//要获得下标index处的值，必须从dummyHead处走index+1 步 (0至index ) temp才能走到index位置 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        temp.next = dummyHead.next;</span><br><span class="line">        dummyHead.next = temp; <span class="comment">//保持虚拟头结点 的 相对位置</span></span><br><span class="line">        size ++ ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="comment">//java while循环中 判断条件 限制，以下while为错误的</span></span><br><span class="line">        <span class="comment">// while(index--)&#123;</span></span><br><span class="line">        <span class="comment">//     temp = temp.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//虚拟头结点 temp 指向插入处的前一个node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index ; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        newNode.next = temp.next; </span><br><span class="line">        temp.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">		<span class="comment">//指向要删除的前一个结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; index ; ++i)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>费马和帕斯卡系统</title>
    <url>/2021/06/27/%E6%9D%82%E4%B9%A6/%E8%B4%B9%E9%A9%AC%E5%92%8C%E5%B8%95%E6%96%AF%E5%85%8B/</url>
    <content><![CDATA[<p>《费马和帕斯卡系统的思维模型》；任何思维模型，在了解了其背后的原理后，都需要自己在实际生活中刻意去练习。费马帕斯卡系统给我们的启示是要用实际的概率去分析和做决策，不能以表面现象和自身经验去下结论。查理芒格说，我们只有把这些基础的不自然的数学概率方法变成我们生活的一部分，才不会把自己的优势拱手让给别人。</p>
<p>在知识、能力、努力、耐心这些所有的品质中，查理芒格最看重的是理性。查理芒格说：“你必须看到这个世界真实的样子，而不是你以为的样子、或者你希望的样子，只有这样你才能做出正确的选择。”费马帕斯卡系统就是认识真实世界的基本工具。<br><strong>费马帕斯卡系统是现代概率论的基础，来自一个概率论中的经典问题——点数问题（Problem of points），也叫赌注分配。</strong></p>
<p><img src="/img/%E8%B4%B9%E9%A9%AC%E5%92%8C%E5%B8%95%E6%96%AF%E5%8D%A1%E7%B3%BB%E7%BB%9F.jpg" alt="费马和帕斯卡"></p>
<p><strong>如果你们懂得基本的心理学原理，就能理解人们做不到这一点的原因。其实很简单：大脑的神经系统是经过长期的基因和文化进化而来的，它并不是费马—帕斯卡系统，它使用的是非常粗略而便捷的估算，里面有一点费马—帕斯卡系统的元素，但是不精准。—— 查理.芒格</strong></p>
]]></content>
      <categories>
        <category>杂书</category>
      </categories>
      <tags>
        <tag>思维模型</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2021/06/27/%E5%80%92%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<p>题意：反转一个单链表。</p>
<p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。</p>
<p>其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:</p>
<p><img src="/img/%E5%8F%8D%E8%BD%AC.jpg" alt="反转"></p>
<p>之前链表的头节点是元素1， 反转之后头结点就是元素5 ，这里并没有添加或者删除节点，仅仅是改表next指针的方向。</p>
<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p><img src="/img/%E5%8F%8D%E8%BD%AC.gif" alt="反转"></p>
<p>首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。</p>
<p>然后就要开始反转了，首先要把 cur-&gt;next 节点用tmp指针保存一下，也就是保存一下这个节点。</p>
<p>为什么要保存一下这个节点呢，因为接下来要改变 cur-&gt;next 的指向了，将cur-&gt;next 指向pre ，此时已经反转了第一个节点了。</p>
<p>接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。</p>
<p>最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。此时我们return pre指针就可以了，pre指针就指向了新的头结点。</p>
<p>整体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummpyNode = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = dummpyNode;</span><br><span class="line">            dummpyNode = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// dummpyNode = cur;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummpyNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以下小问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur;</span><br><span class="line">            cur.next = dummpyNode;</span><br><span class="line">            dummpyNode = temp;</span><br><span class="line">            cur = temp.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个while是错误的，新建了临时节点temp，并将cur赋值给了temp，这并不是另批一个空间节点，把cur的值和下一跳给了temp。而是让temp也指向了链表中的cur节点，也就是说，temp和cur指向了同一块内存地址。所以下面一改cur.next，temp也就跟着变了，后面自然也就跟着错误了。</p>
]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表倒数第N个节点</title>
    <url>/2021/06/27/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p>
<p>示例 2：<br>输入：head = [1], n = 1<br>输出：[]</p>
<p>示例 3：<br>输入：head = [1,2], n = 1<br>输出：[1]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
<p>思路是这样的，但要注意一些细节。</p>
<p>分为如下几步：</p>
<ul>
<li><p>首先推荐使用虚拟头结点，这样方便实现删除实际头结点的逻辑</p>
</li>
<li><p>定义fast指针和slow指针，初始值为虚拟头结点</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/1.jpg" alt="1"></p>
</li>
<li><p>fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/2.jpg" alt="2"></p>
</li>
<li><p>fast和slow同时移动，之道fast指向末尾</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/3.jpg" alt="3"></p>
</li>
<li><p>删除slow指向的下一个节点</p>
<p><img src="/img/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/4.jpg" alt="4"></p>
</li>
</ul>
<h1 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummpyNode = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        dummpyNode.next = head;</span><br><span class="line">        ListNode fast = dummpyNode ;</span><br><span class="line">        ListNode slow = dummpyNode;</span><br><span class="line">        <span class="comment">//fast先走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//一起往前走</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummpyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h1><p>上述fast先走n+1步，再和slow一起走，所以为啥是n+1，n可以吗？</p>
<p>答案是肯定的，先走n步完全是可以的，只不过这样走到最后slow就到了要删除的节点上，所以要在while里多做一步处理，记录下slow前面的节点，方便最后删除。</p>
<p>改动核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">     prev = slow; <span class="comment">//记录一哈</span></span><br><span class="line">     slow = slow.next;</span><br><span class="line">     fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里prev就起作用了</span></span><br><span class="line">prev.next = slow.next;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式必知必会</title>
    <url>/2021/09/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="4、使用元字符"><a href="#4、使用元字符" class="headerlink" title="4、使用元字符"></a>4、使用元字符</h1><p>元字符：正则表达式中有着特殊含义的字符(如’ .‘表示任意字符,[]表示字符区间)，这些字符要表达其本身意思的话，就要使用反斜杠字符\来转义</p>
<h2 id="4-1-匹配空白字符"><a href="#4-1-匹配空白字符" class="headerlink" title="4.1 匹配空白字符"></a>4.1 匹配空白字符</h2><p>\n 换行符</p>
<p>\r 回车符</p>
<p>\t 制表符</p>
<p>windows中文本行结束标志为 \r\n</p>
<p>\r  是指针回到本行的首字符处</p>
<p>\n 是跳到下一行原处</p>
<p><a href="https://blog.csdn.net/amqvje/article/details/38370681">\r\n解释</a></p>
<h3 id="4-2-匹配特定的字符类型"><a href="#4-2-匹配特定的字符类型" class="headerlink" title="4.2 匹配特定的字符类型"></a>4.2 匹配特定的字符类型</h3><h3 id="4-2-1-匹配数字"><a href="#4-2-1-匹配数字" class="headerlink" title="4.2.1 匹配数字"></a>4.2.1 匹配数字</h3><p>[0-9] 匹配任何一个数字  等价于 \d</p>
<p>[^0-9] 等价于\D</p>
<h3 id="4-2-2-匹配字母数字"><a href="#4-2-2-匹配字母数字" class="headerlink" title="4.2.2 匹配字母数字"></a>4.2.2 匹配字母数字</h3><p>[a-zA-Z0-9_]   任何一个字母数字字符或下划线  等价于 \w</p>
<p>[^a-zA-Z0-9_]  \W</p>
<p>4.2.3 匹配空白字符</p>
<p>[\f\n\r\t\v] 任何一个空白字符 等价于 \s</p>
<p>[^\f\n\r\t\v] 任何一个非空白字符 等价于 \S</p>
<h1 id="5、重复匹配"><a href="#5、重复匹配" class="headerlink" title="5、重复匹配"></a>5、重复匹配</h1><p>+是一个元字符</p>
<h2 id="5-1匹配一个或多个字符"><a href="#5-1匹配一个或多个字符" class="headerlink" title="5.1匹配一个或多个字符"></a>5.1匹配一个或多个字符</h2><p>[a-zA-Z0-9_]+   或 \w+</p>
<p>邮箱地址 ： \w+@\w+.\w+</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\w+@\w+\.\w+</span><br></pre></td></tr></table></figure>

<p>但不能识别全 <a href="mailto:&#98;&#x65;&#x6e;&#46;&#102;&#111;&#x72;&#x74;&#64;&#x66;&#x6f;&#x72;&#116;&#x2e;&#99;&#111;&#x6d;">&#98;&#x65;&#x6e;&#46;&#102;&#111;&#x72;&#x74;&#64;&#x66;&#x6f;&#x72;&#116;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>匹配字符集合: [\w.]  字符集中. + 这样的元字符不需要转义，被解释为普通字符。但转义了也没有坏处，效果是一样的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[\w.]+@[\w.]+\.\w+</span><br></pre></td></tr></table></figure>

<h2 id="5-1-2匹配零个或多个字符"><a href="#5-1-2匹配零个或多个字符" class="headerlink" title="5.1.2匹配零个或多个字符"></a>5.1.2匹配零个或多个字符</h2><p>+至少要匹配一个目标字符</p>
<p>*匹配一个可有可无的字符</p>
<p>[\w.]* 匹配.或字母数字字符的零次或多次重复</p>
<p><a href="mailto:&#x2e;&#98;&#x65;&#110;&#64;&#49;&#x35;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#x2e;&#98;&#x65;&#110;&#64;&#49;&#x35;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\w+[\w.]*@[\w.]+\.\w+</span><br></pre></td></tr></table></figure>

<p>过滤掉邮箱前面的.</p>
<h2 id="5-1-3匹配零个或一个字符"><a href="#5-1-3匹配零个或一个字符" class="headerlink" title="5.1.3匹配零个或一个字符"></a>5.1.3匹配零个或一个字符</h2><p>? 匹配可选文本，就算文本没有出现，也可匹配。但是与+不同， ？只能匹配某个字符（或字符集合）的零次或一次出现，最多不超过一次。</p>
<p>匹配URL地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https?:\/\/[\w.\/]+</span><br></pre></td></tr></table></figure>

<p>可匹配http://，也可匹配https:// 。</p>
<h2 id="5-2匹配的重复次数"><a href="#5-2匹配的重复次数" class="headerlink" title="5.2匹配的重复次数"></a>5.2匹配的重复次数</h2><p>{和}是元字符</p>
<h2 id="5-2-1-具体的重复匹配"><a href="#5-2-1-具体的重复匹配" class="headerlink" title="5.2.1 具体的重复匹配"></a>5.2.1 具体的重复匹配</h2><p>{3} 意味着匹配前一个字符（或字符集合）3次，如果只能匹配两次，则不算匹配成功。</p>
<h2 id="5-2-2区间范围"><a href="#5-2-2区间范围" class="headerlink" title="5.2.2区间范围"></a>5.2.2区间范围</h2><p>{2,4} 最少匹配2次，最多匹配4次</p>
<p>重复范围也可以从0开始，{0,3}表示重复次数可以是0,1,2,3.  ？等效于{0,1}</p>
<h2 id="5-2-3-匹配-至少重复多少次"><a href="#5-2-3-匹配-至少重复多少次" class="headerlink" title="5.2.3 匹配 至少重复多少次"></a>5.2.3 匹配 至少重复多少次</h2><p>{3,} 表示至少重复3次</p>
<p>+在功能上等效于{1,} </p>
<h1 id="6、位置匹配"><a href="#6、位置匹配" class="headerlink" title="6、位置匹配"></a>6、位置匹配</h1><h2 id="6-1-边界-boundary"><a href="#6-1-边界-boundary" class="headerlink" title="6.1 边界 boundary"></a>6.1 边界 boundary</h2><p>元字符 ： \b</p>
<h2 id="6-2-单词边界"><a href="#6-2-单词边界" class="headerlink" title="6.2 单词边界"></a>6.2 单词边界</h2><p>\b 匹配的是字符之间的一个位置 : 一边是单词(能够被\w匹配到的) ， 另一边是其他内容(被\W匹配到的字符)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">the cat scattered his food</span><br><span class="line">正则：</span><br><span class="line">\bcat\b</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射机制</title>
    <url>/2021/09/09/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.syl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我吃&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//利用反射机制调用类的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取类的字节码，字节码是根据源代码生成的，</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;com.syl.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、利用反射机制创建一个对象，以下的api 就是 调用类的无参构造器来实例化对象的</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、反射出 字节码中的某个方法</span></span><br><span class="line">        Method M = clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        Method m = clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、利用反射机制调用方法</span></span><br><span class="line">        <span class="comment">//把m 所代表的方法，当做obj对象的方法来调用</span></span><br><span class="line">        M.invoke(obj);</span><br><span class="line">        m.invoke(obj,<span class="string">&quot;大米饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>String类</title>
    <url>/2021/09/09/String%E7%B1%BB/</url>
    <content><![CDATA[<p>一、什么是String ?</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符串不变; 它们的值在创建后不能被更改(字符串是长度不可以改变字符序列)。</span><br><span class="line">String是一个引用数据类型</span><br><span class="line">是jdk给我们提供好的一个现成的String类</span><br><span class="line"><span class="string">&quot;abc&quot;</span>既是一个字符串常量，也是一个字符串的对象(实例)</span><br></pre></td></tr></table></figure>

<p>二、常见的构造方法？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.public String()：初始化一个新创建的 String 对象，使其表示一个空字符序列</span><br><span class="line">2.public String(byte[] bytes)：将字节数组转换成字符串</span><br><span class="line">3.public String(byte[] bytes,int offset,int length)：将字节数组的一部分转换成字符串</span><br><span class="line">4.public String(char[] value)：将字符数组转换成字符串</span><br><span class="line">5.public String(char[] value,int offset,int count)：将字符数组的一部分转换成字符串</span><br><span class="line">6.public String(String original)：初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列</span><br><span class="line">7.String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">常见问题？</span><br><span class="line">问题1：</span><br><span class="line">通过new出来的String对象和直接赋值的String对象有什么区别？</span><br><span class="line">通过new出来的，在内存中有2个对象</span><br><span class="line">通过直接赋值的对象，在内存只有1个对象</span><br><span class="line"></span><br><span class="line">问题2：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s3 = new String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);//<span class="literal">true</span></span><br><span class="line">System.out.println(s1 == s3);//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">问题3：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">String s3 = s2 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);//<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">问题4：</span><br><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;ab&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);//<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>三、常见成员方法？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.public char charAt(int index)：获取指定索引对应的字符</span><br><span class="line">2.public int compareTo(String anotherString)：按字典顺序比较两个字符串。</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;bccde&quot;</span> -&gt; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">对位比较，如果对位相等，去下一位再继续比</span><br><span class="line">3.public String concat(String str)：字符串的拼接</span><br><span class="line">4.public boolean contains(String s)：判断是否包含指定的字符串</span><br><span class="line">5.public String toLowerCase()：将大写字母转换成小写字母</span><br><span class="line">6.public String toUpperCase()：将小写字母转换成大写字母</span><br><span class="line">7.public boolean equals(Object anObject)：比较两个字符串的内容是否一致</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125; arr1[1]</span><br><span class="line"><span class="string">&quot;abcde&quot;</span> -&gt; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125; arr2[1]</span><br><span class="line">8.public boolean equalsIgnoreCase(String anotherString)：比较两个字符串的内容是否一致(不区分大小写)</span><br><span class="line">9.public int indexOf(int ch)：获取指定字符对应的索引值，如果找不到返回-1</span><br><span class="line">10.public int indexOf(String str)：获取指定字符串对应的索引值，如果找不到返回-1</span><br><span class="line">11.public int lastIndexOf(int ch)：获取指定字符对应的最后第一次出现的位置的索引，如果找不到返回-1</span><br><span class="line">12.public boolean isEmpty()：判断字符串是否为空串</span><br><span class="line">13.public int length()：获取字符串的长度</span><br><span class="line">14.public boolean startsWith(String prefix)：判断是否以指定的字符串为前缀的，开头</span><br><span class="line">15.public boolean endsWith(String suffix)：判断是否以指定的字符串为后缀的，结尾</span><br><span class="line">16.public String replace(char oldChar,char newChar)：替换字符</span><br><span class="line">17.public byte[] getBytes():将字符串转换成字节数组</span><br><span class="line">18.public char[] toCharArray()：将字符串转换成字符数组</span><br><span class="line">19.public String trim()：去除字符串的前后空格</span><br><span class="line">20.public String substring(int beginIndex):截取，从指定的索引开始截取到末尾</span><br><span class="line">21.public String substring(int beginIndex,int endIndex)：</span><br><span class="line">截取，从指定的beginIndex索引开始截取到endIndex(包头不包尾)</span><br><span class="line">22.public String[] split(String regex)：按照指定的符号进行切割，根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">正则表达式：是一个字符串，在字符串里面写一些规则，可以帮助对指定的String数据进行校验</span><br><span class="line">23.public String replace(String target,String replacement)：替换子字符串</span><br><span class="line"></span><br><span class="line">练习：</span><br><span class="line">需求：遍历字符串</span><br><span class="line">方式一：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String[] strs = s.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">char ch = s.charAt(i);</span><br><span class="line">System.out.println(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方式三：</span><br><span class="line">String s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">char[] chs = s.toCharArray();</span><br><span class="line"><span class="keyword">for</span>(int i = 0; i &lt; chs.length; i++) &#123;</span><br><span class="line">System.out.println(chs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">需求：已知字符串String s = <span class="string">&quot;adfasADFJASadfljdasjSFADASLJadfjaldj&quot;</span>;将首字母变大写，其余都变小写？</span><br><span class="line">System.out.println(s.substring(0, 1).toUpperCase().concat(s.substring(1).toLowerCase()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
</search>
